
## Security

The Internet is often seen as a magical grove, with the sum total of human knowledge at your fingertips and a land of unlimited
opportunities. If you dig down just a little bit, you'll find that this is not a magic grove, but a haunted woods. The Internet
is a hostile place, with very little trust given or expected. A network packet traveling between two machines is likely to 
be intercepted, inspected, logged and modified before it reaches its destination. 

From re-writing links to downloads to include malware to phising sites that will steal your passwords and then your identity, the
ideal of a network that is safe to browse is very far from reality. You don't typically notice this, because the baseline 
assumption is, and has been for a while, that the network itself it hostile. Website uses certificates and top of the line 
encryption to idenitify themselves and hide the content of requests and responses over the wire, digital signatures are sent and
validated automatically by your browser and platform.

We have reached the stage where it is required to use military grade encryption, to upload the lunch selfie that is going to be 
uploaded to the cloud for all to see. There is so much encryption around us that we don't really notice. From the green lock icon
on the browser to common chat platforms employing end to end encryption, forward security and authentication. When the network is
hostile, only the foolish will go forth without the armor of encryption.

This chapter is not meant to be a thorough discussion of security practices in general. There have been many books published on 
the subject that deals in many aspects of the problem. From how to protect your data and services to how to break into 
insufficently protected locations and ransack their contents. 

We are going to focus on understanding the threat model your RavenDB instances face and what kind of features RavenDB has to deal
with such threats. This chapter is all controlling who can access the data inside your databases, protecting the conversation 
between client applications and that database from being eavesdropped or modified as well as protecting the data on disk from 
being usable if it is stolen.

> **Running RavenDB in unsecured mode**
>
> It might be surprising to hear, but it is very common to run RavenDB with no security whatsoever. This is typically what you'll
> have when RavenDB is running on a developer machine. By default, this mode is only allowed as long as RavenDB is listening to
> either `127.0.0.1`, `::1` or `localhost`. In other words, as long as RavenDB is not listening on the network^[RavenDB will 
> _refuse_ to run in this mode while listening to other IPs unless you explicitly tell it that you are fine with an unsecured 
> setup.].
>
> In such a mode, _none_ of the security features of RavenDB are accessible. You cannot authenticate users (anyone listening on
> the network would be able to hijack the connection, after all) nor can you create or use encrypted databases (anyone can
> access the server and get the encrypted data, so why bother).
>
> Note that even in development mode, it is still _strongly_ recommended that you'll run in a secured configuration. The RavenDB
> team have worked _hard_ to make sure that running in a secured mode is easy, preceisely because of this. Your default mode 
> should be a secured one.

So far, we have run RavenDB in its unsecured configuration, suitable only for development work in a secured network. In any other
case, you'll want to run RavenDB in a secured mode. A core part of the design of RavenDB has been security, and most importantly,
making sure that running RavenDB in a secured fashion is _easy_ enough to be the default. 

### Introduction to transport level security and authentication

I'm going to assume that you have little to no knowledge about security. This is likely false, but it is better to give you 
information that you already have than miss something critical. Securing a RavenDB server requires that we'll take care of the 
following issues:

1. Allow the client to verify that the database server is indeed the one we wanted to talk to. 
2. Allow the server to verify that the client is a valid one and to decide what access it should have.
3. Prevent anyone else from eavedropping to the communication between server and client, hijack the client credentials, etc.

RavenDB is not the first to have these set of requirements and instead of rolling our system^[Roll your own is usually a _bad_
idea with security practices.] it uses the TLS 1.2^[TLS - Transport Level Security, the successor to SSL and what is actually 
used when you are using HTTPS, for example.] protocol. You might not be familiar with the term, but a more common use name for
this is HTTPS. RavenDB uses TLS 1.2 in the following ways:

* The database server identifies itself with a `X509` certificate to clients.
* Clients use `X509` client certificate to identify itself to the server.
* All traffic between the database and clients is encrypted.

TLS 1.2 is the recommended protocol for secured communication by NIST and PCI 3.1 and in Dec 2017 was the chosen protocol for
close to 90% of the entire encrypted web traffic world wide.

If you have previously deployed a website or application using HTTPS, you are already familiar with the key problem of using 
TLS / HTTPS, the certificate. Rather more to the point, _getting_ a certificate.

A certificate, according to [Wikipedia](https://en.wikipedia.org/wiki/Public_key_certificate), is: "is an electronic document
used to prove the ownership of a public key". That doesn't really mean much to a layperson. A certificate is a way for a service
to identify itself in a crytographically secured manner. There are two types of certificates that usually interest us, self-signed
certificates and certificated signed by a Certificate Authority (CA). 

A self signed certificate is similar to a post-it note at a class reunion, while a certificate signed by a CA is more like an 
official ID. Figure 13.1 might make things easier to explain.

![Self signed vs. CA certificates, in real world terms.](./Ch13/img01.png)

Unlike the real world, certificate uses cryptographic signatures to identify themselves. You can assume that if the connection
is using a certificate, then no outside party can listen to the contents of the traffic between client and server. That, as it
turns out to be, is just half of the issue. Consider going to your class re-union, seeing a name tag that say "Your Best 
Friend From High School" and then whispering a dire secret to that person. 

You can be sure that your secret has only reached that person's ears, but the fact that they have a name tag with a particular
name doesn't actually mean that they _are_ that person. In the real world, you'll typically use a government issued id to 
verify identity. There is a much higher level of trust given to a driver license with your details than to a post-it note with
a hand written name.

In the same sense, you have a self signed certificate (which ensures that the connection is private, but doesn't gurantee who
you are talking to) and you have a CA signed certificate. A CA is supposed to do some level of validation before issuing a 
certificate. And as part of issuing the certificate, it will sign it using its own cryptographic signature. This way, you have
a list of trusted CA (called the Root CAs) and by default you'll trust that certificates that you run into that are signed by
those CA are valid. 

> **What does it means, CA validation?**
> 
> There are different types of certificates that you can use. They range from Domain Validation (DV), code signing, Extended
> Validation (EV) and many more usages. For the purpose of RavenDB, we only care about DV certificates, which allow you 
> to verify that the server you are talking to is actually the server you _think_ that you are talking to.
> 
> The purpose of a domain validation certificate is to ensure that when you type `https://db.example.org` your connection will
> not be intercepted in the middle. This is done by getting a certificate from the server and checking that it is indeed signed
> for this domain and by someone that you trust.
>
> It's important to note that this is _all_ it does. Most CAs will only check that you have control over that domain before
> issuing a certificate. And if you have the certificate for a site, you can absolutely pretend to be that site. If you have
> bought the domain `example.org` you can get a certificate for `db.example.org`, but unless you have _really_ good eyes and
> a good font choice, you wouldn't know that the `a` character in the domain is not U+0061 but actually U+0251, a completely
> different letter, resulting in a different domain. 
> 
> I'm using the Unicode letters because it is so sneaky, but the same rules apply to `exampel.org` or `examp1e.org`. One can
> mislead you by a typo and the other with `1` vs `l`. At the time of this writing, both domains were actually available for
> purchase, by the way.
> 
> Another asepct of security to consider is who you trust. For example, inside an organization, the admins usually have a 
> root certificate installed on all the machines, so they can generate certificate for any site they wish to. 

A CA can be one of the global Root CAs (such as Comodo, IdenTrust, DigiCert and Let's Encrypt), which are trusted by most 
browsers and operating systems or it can be a local CA. For example, the operations teams define a root certificate that is 
trusted by all your machines, and used that to generate certificates. The real world parallel for a local root CA is 
accepting employee ID cards as proof of identity inside a company. 

#### Certificate usage inside RavenDB

RavenDB uses certificates for all communication and authentication needs. This has the advantage that _anything_ can talk to
RavenDB, because HTTPS is so widely supported. Operations teams are also used to handling certificates, securely storing them,
renewal, revocation, etc. 

By default, the client API will trust the server if the server's certificate is a match to the expected URL, the certificate is
valid and the certificate is signed by a trusted party. You can override such decisions by setting the 
`RequestExecutor.ServerCertificateCustomValidationCallback` and do you validation logic there. This is useful if you are using
self-signed certificates that aren't trusted by the client, or if you want to verify additional properties on the certificate. 

When running in a secured mode, RavenDB required that the client, as well, will authenticate using a `X509` certificate. This
is called a client certificate and it allows the client and server to establish a mutually authenticated channel between them.
The server certificate requires that the client trust it and using the Root CA and the trust chains that are 
defined on the client machine. For the server to trust a client certificate, that certificate needs to be explicitly registered
in the cluster. 

> **Reducing optional attach surface**
> 
> Part of the security design for RavenDB is that its security comes with a single on/off switch. The unsecured mode for 
> RavenDB uses plain text transport only (HTTP), supports no authentication and cannot use encrypted databases. It can
> also only talk to other unsecured servers and be part of an unsecured cluster. 
>
> On the other hand, in the secured mode, we use HTTPS and TLS 1.2 for all communications, require authentication for all
> operations (using client certificates) and can only talk to other secured servers and be part of a secured cluster. This
> also allows us to have encrypted databases.
>
> The reasoning is that by not allowing a secured server with no authentication we prevent operator mistakes from exposing
> production machines to the world. Sadly, this is a _very_ common occurance and something that we have strived to make
> difficult to do by accident. 

We'll go through exactly how to do that in the next section, for now, I want to focus on the general theory and what exactly
is going on before diving into how you'll operate it.

Client certificate are easy, the only thing that needs to trust them is RavenDB, and we can either register a certificate
with the cluster directly, or ask the cluster to generate them for us. Getting a server certificate is usually much more
complex, because you need to deal with trust issues and in many organizations, access to certifciates is tightly controlled
(and right so). 

Let's us see what RavenDB does to make secured setup easier. 

### Setting RavenDB up in a secured fashion

Setting up RavenDB in a secured mode is a fairly simple process. You can do it yourself by setting the right configuration values
and deploy it directly. However, the first time that you'll start a RavenDB instance you'll be direct to the setup wizard, where
you can make important decisions about how RavenDB will be deployed. You can see how this look slike in Figure 13.2. 

![The setup wizard is the first screen you'll see when accessing RavenDB for the first time](./Ch13/img02.png)

You have four options available. You can setup RavenDB by generating a certificate through `Let's Encrypt`, use your own 
certificate, setup RavenDB in _unsecured_ mode or complete the setup process for a cluster node that was started on another
instance. 

> **Using `Let's Encrypt`**
>
> Part of the reason TLS and HTTPS aren't used everywhere is the issue of certificates. In order for a certificate to be useful
> you need it to be trusted, which means that you need to get it from one of the Root CAs. Up until recently, that was something
> that you could only get in a commercial setting. This severly limited HTTPS adoption and made it a lot more complex
> 
> Enter `Let's Encrypt`, whose mission is to bring HTTPS everywhere, by providing free, trusted, certificiates to all in an 
> fully-automated manner. The only requirement that `Let's Encrypt` has is that you prove in some manner that own the domain
> for which you are requesting a certificate. 

The online documentation does an excellent job in walking you through all the options of setting up RavenDB, so I'm not going
to go into detail on each and every option. Instead, I'm going to walk you through setting up a RavenDB cluster in a production
mode in as few a steps as possible. Right now, my focus is the security of the solution, we'll talk a lot more about deployment
options on later chapters.

First, uncompress the RavenDB server package (available on the [https://ravendb.net/downloads](https://ravendb.net/downloads))
three times, to `raven/srv-a`, `raven/srv-b` and `raven/srv-c`. We are going to run three instances of RavenDB on a single 
machine, but you can follow the exact same steps to setup RavenDB on multiple machines. Just be sure to get the IP addresses
correctly and to open the relevant ports in the firewalls.

> **`Let's Encrypt` is completely optional**
> 
> It's important to note that this part of the process is _entirely_ optional. You can run your RavenDB instance using your own
> certificates and your own domains. This is provided to make it easy to setup RavenDB in a secured manner.
> 
> For most operation teams, certificate and domain management is their bread and butter and RavenDB couldn't care less about
> where you got your certificate from. You can use the same setup process with your own certificate by selecting 
> `Provide Your Own Certificate` option. 

First, run the `raven/srv-a/run.sh` (Linux) or `raven/srv-a/run.ps1` (Windows) script. This should start the RavenDB instance
and open your browser automatically. If this does not happen, look for the `"Server available on: <url>"` line on the 
command line and go the the specified url. 

You should see a screen similar to Figure 13.2. 

> **Automatic certificate generation requires a (free) license**
>
> `Let's Encrypt`'s free certificate generation helps a lot, but to actually generate a certificate, you need to have a domain
> that you own that you can use to generate the certificate. In many cases, you are deploying only internally, without having
> any external access.
>
> To alleviate a lot of the complexity of such deployment, RavenDB take upon itself to handle all of that. The RavenDB team is
> managing a set of root level domains from which it allocates subdomains to users, and RavenDB uses these subdomains to create
> the certificate.
> 
> These domains looks like: `<name>.development.run` or `<name>.ravendb.community`, where you can provide any `<name>` you want
> as long as it wasn't taken first by someone else. 
>
> Names are provided on a first come, first serve basis, and once they have been given to a user, they are associated with the
> user permenantly. This is because we need to be sure that only a single user ever got a specific domain. 
> This is to avoid the option of two users having certificates to the same domain, which will allow them to capture traffic 
> meant to the other.
> 
> You can request a free license from the RavenDB site and use that license during the setup process to register your domain name
> and then get the certificate to run RavenDB securely. That license is tied then tied to the domain and can be used later to 
> modify the domain's settings and to generate another certificate. 

On the setup screen, select the `Generate Let's Encrypt Certificate`, provide the license that you recieved over email (you can
get a free license by registering on the RavenDB website) and click next. You can see the next screen in Figure 13.3.

![The domain selection page allows you to select the name of your cluster.](./Ch13/img03.png)

The domain selection screen in Figure 13.3 is where you can select your domain name. This will also be how you'll usually refer to
your cluster. If this is the first time you are running through the process, you'll need to select name. As long as it isn't already
taken by someone else, you will be granted the name. If you have already setup RavenDB, you'll be able to select from the domain 
names you have previous registered. After selecting the domain name, click next. 

You'll be faced with the cluster setup, as shown in Figure 13.4. We're setting a local cluster, so set the `HTTP Port` to `443`,
the `IP Address` to `127.0.0.2` for node `A`, 



### Authentication and authorization

### Encryption at rest

### Key management



# Deep dive into the RavenDB Client API

In this chapter we are going to take a deep dive into how the client API works. We are going to show mostly C# code examples, but the 
same concepts apply to any of the RavenDB Client APIs, regardless of platforms, with minor changes to make it fit the platform.

There are still some concepts that we haven't gotten around to (clustering or indexing, for example) which will be covered in 
their own chapters. But the Client API is very rich and has a lot of useful functionality on its own, quite aside from the server
side behavior. 

We already looked into the document store and the document session, the basic building blocks of CRUD in RavenDB. But in this chapter we
are going to look beyond the obvious and into the more advanced features. One thing we'll _not_ talk about in this chapter is querying.
We'll talk about that extensively in [Chapter 9](#map-indexes), so we'll keep it there. You already know the basic of querying in RavenDB
but there is a _lot_ more power waiting for you to discover there.

This chapter is going to contain a _lot_ of code examples and discuss the nitty gritty details of using the client. It is also divided into 
brief sections that each deal with a specific feature or behavior. I suggest reading over this to note what the capabilities of RavenDB are
and coming back to it as needed in your application.

For the rest of this chapter, we'll use the classes shown in Listing 4.1 as our model, using a simplified help desk as our example. 

```{caption="Simplified Help Desk sample model" .cs}
public class Customer
{
	public string Id { get; set; }
	public string Name { get; set; }
}

public class SupportCall
{
	public string Id { get; set; }
	public string CustomerId { get; set; }
	public DateTime Started { get;set; }
	public DateTime? Ended { get;set; }
	public string Issue { get; set; }
	public List<string> Comments { get; set; }
}
```

## Writing documents

Writing documents in RavenDB is easy, as we saw in [Chapter 2](#zero-to-ravendb). If we want to create a new support call, we can use the code in 
Listing 4.2 to do so.

```{caption="Creating a new support call using the session" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);
	session.SaveChanges();
}
```

This is basic behavior of RavenDB, and how you would typically work with saving data. But there are lot of additional things that we can do when
writing data. For example, the user might have sent us some screen shots that we want to include in the support call. 

### Working with attachments

You can add attachments to a RavenDB document to store binary data relating to that document. Let us assume that the user have sent us a screen shots
of the problem along with the call. Listing 4.3 shows how we can store and retrieve the attachments.

```{caption="Saving attachments to RavenDB as part of opening the support call" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);

	foreach(var file in attachedFiles)
	{
		session.Advanced.StoreAttachment(call, file.Name, 
			file.OpenStream());
	}

	session.SaveChanges();
}
```

Note that we are using the session to store both the support call document and any attachments that the user might have sent. An attachment is basically
a file name and a stream that will be sent to the server (with an optional content type). When the call to `SaveChanges` is made, the RavenDB Client API
will send both the new document and all of its attachments to the server in a single call, which will be treated as a transaction. Both the document and
the attachments will be saved, or both will fail.

That was easy enough, but how do we get those back? The list of attachments for a particular document is accessible via the document metadata, as shown
in Listing 4.4. 

```{caption="Getting the list of attachments for a support call" .cs}
using(var session = store.OpenSession())
{
  var call = session.Load<SupportCall>("SupportCalls/238-B");
  var attachments = session.Advanced.GetAttachmentNames(call);

  // render the call and the attachment names
}
```

Calling `GetAttachmentNames` is cheap, since the attachments on a document are already present in the document metadata, which we loaded as part of
getting the document. There is no server side call involved. Note that the result of `GetAttachmentNames` does not include the _content_ of the 
attachments. To get the attachment itself, and not just its name, you need to make a separate call, as shown in Listing 4.5.

```{caption="Getting an attachment content" .cs}
using(var session = store.OpenSession())
{
	var call = session.Load<SupportCall>("SupportCalls/238-B");
	var attachments = session.Advanced.GetAttachmentNames(call);

 	using(var stream = session.Advanced.GetAttachment(call, 
 		attachments[0].Name))
 	{
		// process the content of the attachment 	
 	}
}
```

Each call to `GetAttachment` will make a separate call to the server to fetch the attachment, if you have a lot of attachments, be aware that 
fetching all of their information can be expensive due to the number of remote calls that are involved. 

### Working with the document metadata

In the attachments section, we noted that attachment information is stored in the document metadata. RavenDB used the metadata for a lot of things,
most of them you don't generally care about (etag, change vector, etc). But the document metadata is also available to you for your own needs and 
use. 

Actual use case for direct use of the document metadata are actually pretty rare. If you want to store some information, you'll typically want to 
store it in the document itself, not throw it to the sidelines in the metadata. Typical use cases for storing data in the medata are corss cutting
concerns. The preeminent one is auditing (who editted this document, for example). 

In order to demonstrate working with the metadata, we'll consider the case that creating a support call is a complex process that has to go through
several steps. In this case, while we saved the document to RavenDB, it is still in draft status. Typical modeling advice would be to model this 
explicitly in the domain (so you'll have a `IsDraft` or `Status` property on your model), but for this example, we'll use the metadata. You can see
the code for setting a draft status in the metadata in Listing 4.6.

```{caption="Setting a metadata flag as part of creating a new support call" .cs}
using(var session = store.OpenSession())
{
	var call = new SupportCall
	{
		Started = DateTime.UtcNow,
		Issue = customerIssue,
		CustomerId = customerId
	};
	session.Store(call);

	var metadata = session.Advanced.GetMetadataFor(call);
	metadata["Status"] = "Draft";
	
	session.SaveChanges();
}
```

We can call `GetMetadataFor` on any document that has been associated with the session. A document is associated with the session either by loading
it from the server or by calling `Store`. After the document has been associated with the session, we can get its metadata and manipulate it.

Changes to the metadata count as changes to the document and will cause the document to be saved to the server when `SaveChanges` is called. 

### Change tracking and `SaveChanges`

The document session implements change tracking on your documents as you can see in Listing 4.7.

```{caption="Setting a metadata flag as part of creating a new support call" .cs}
using(var session = store.OpenSession())
{
  var call = session.Load<SupportCall>("SupportCalls/238-B");
  
  call.Ended = DateTime.UtcNow;

  session.SaveChanges();
}
```

The change tracking (and identity map) by the session means that you don't have to keep track of what changed and manually call `Store`. Instead, when
you call `SaveChanges` all you changes will be sent to the server in a single request. 

You have a few knobs available to tweak the process. `session.Advacned.HasChanges` will let you know if calling `SaveChanges` will result in a call to the 
server and `session.Advanced.HasChanged(entity)` will tell you whatever a particular `entity` has changed. You can also take it up a notch and ask RavenDB
to tell you _what_ changed using `session.Advanced.WhatChanged()`, which will give you all the changes that happened in the session. The `WhatChanged` 
feature can be very nice if you want to highlight changes for user approval, for example, or just want to see what modification happened in your model
after a certain operation.

You can also tell RavenDB to not update a particular instance by calling `session.Advanced.IgnoreChangesFor(entity)`. The document will remain attached to
the session, and will be part of any identity map operations, but it won't be saved to the server when `SaveChanges` is called. Alternatively, you can call
`session.Advanced.Evict(entity)` to make the session completely forget about a document. 

All of those operations tend to be very rare and are usuallly used only in very specific cases, but they are very powerful when utilized properly. 

### Optimistic concurrency

We covered optimistic concurrency in [Chapter 3](#modeling), but only in the most general terms. Now, let us take a look at see how we can use optimistic
concurrent in practice. Listing 4.8 shows two simultaneous sessions modifying the same support call. 

```{caption="Concurrent modifications of a support call" .cs}
using(var sessionOne = store.OpenSession())
using(var sessionTwo = store.OpenSession())
{
  var callOne = sessionOne.Load<SupportCall>("SupportCalls/238-B");
  var callTwo = sessionTwo.Load<SupportCall>("SupportCalls/238-B");
  
  callOne.Ended = DateTime.Today;
  callTwo.Ended = DateTime.Today.AddDays(1);
  
  sessionOne.SaveChanges();
  sessionTwo.SaveChanges();
}
```

In the case of the code in Listing 4.8, we are always going to end up with the support call end date set to tomorrow. This is because by default, RavenDB
uses the `Last Write Win` model. You can control that by setting `store.Conventions.UseOptimisticConcurrency` to true, which will affect all sessions, or
on a case by case basis by setting `session.Advanced.UseOptimisticConcurrency` to true on the session directly.

In either case, when this flag is set, when `SaveChanges` is called, we'll send the modified documents to the server alongside their etag at the time we
read them from the server. This allows the server to reject any stale write. If the flag was set to true, the code in Listing 4.8 will result in a 
`ConcurrencyException` on the `sessionTwo.SaveChanges()` call.

This ensures that you cannot overwrite changes that you didn't see and if you set `UseOptimisticConcurrency` you need to handle this error in some manner.

#### Pessimistic locking

Optimistic locking handle the issue of changes to the document we modified that happened behind our backs. Pessimistic locking prevents them entirely. 
RavenDB does _not_ support pessimistic locking, but while you really need support from the database engine to properly implment it, we can pretend to
have something that is near enough to be interesting to talk about, if not actually use. The following is recipe for using
pessimistic locking in RavenDB, not so much because it is a good idea, but because it allows us to explore several different features and see how they
all work together.

Using pessimistic locking we lock a document for modification until we release the lock (or a certain timeout has gone by). We can build a pessimistic 
lock in RavenDB by utilizing the document metadata and optimistic concurrency. It is easier to explain with code and you can find the `Lock` and `Unlock`
implementations in Listing 4.9.

> **The locks are opt in**
>
> In RavenDB, both the pessimistic lock explored in this section and the optimistic lock in the previous section are opt in. That means that you have to
> explicitly participate in the lock. If you are using `UseOptimisticConcurrency` and another thread isn't, that thread will get the `Last Write Wins`
> behavior (and might overwrite the changes made by the thread using optimistic conccurency).
>
> In the same manner, the pessimistic lock recipe described here is depedant on all parties following it, if there is a thread that isn't, the lock will
> not be respected.
>
> In short, when using concurrency control, make sure that you are using it in all acrodd the board, or it may not hold.

```{caption="Extension method to add pessimistic locking to the session" .cs}
public static IDisposable Lock(
	this IDocumentSession session, 
	string docToLock)
{
  var doc = session.Load<object>(docToLock);
  if (doc == null)
      throw new DocumentDoesNotExistException("The document " + 
      	docToLock + " does not exists and cannot be locked");
  var metadata = session.Advanced.GetMetadataFor(doc);
  if (metadata.GetBoolean("Pessimistic-Locked"))
  {
      // the document is locked and the lock is still value
      var ticks = metadata.GetNumber("Pessimistic-Lock-Timeout");
      var lockedUntil = new DateTime(ticks);
      if (DateTime.UtcNow <=  lockedUntil)
      	throw new ConcurrencyException("Document " + 
      		docToLock + " is locked using pessimistic");
  }
  
  metadata["Pessimistic-Locked"] = true;
  metadata["Pessimistic-Lock-Timeout"] = 	
  	DateTime.UtcNow.AddSeconds(15).Ticks;
  
  // will throw if someone else took the look in the meantime
  session.Advanced.UseOptimisticConcurrency = true;
  session.SaveChanges();
  return new DisposableAction(() =>
  {
      metadata.Remove("Pessimistic-Locked");
      metadata.Remove("Pessimistic-Lock-Timeout");
      Debug.Assert(session.Advanced.UseOptimisticConcurrency);
      session.SaveChanges();
  });
}
```

There is a quite a bit of code in 4.9, but there isn't actually a lot that gets done. We load a document, and check if its metadata contains the
`Pessimistic-Locked` value. If it does, we check whatever the timeout for the lock has expired. If it isn't locked, we update the document metadata,
enable _optimistic_ concurrency and then call `SaveChanges`. If no one else modified the document in the meantime, we will succuessfully mark the 
document as ours, and any other call to `Lock` will fail.

The `Lock` method returns an `IDisposable` instance which handle releasing the lock. This is done by removing the metadata values and then calling 
`SaveChanges` again. If the lock has timed out, and someone took the lock, we'll fail here with concurrency exception as well.

> **Avoid your own distributed pessimistic locks**
>
> There is a reason why RavenDB does not include a pessimistic lock feature, and I strongly recommend to avoid using the recipe above. It is here 
> because it shows how to use several different features at once to achieve a goal. 
>
> Actually handling distributed lock is a non trivial issue. Consider a RavenDB cluster with multiple nodes. If two lock requests will go to two
> distinct nodes at the same time, _both_ of them will succeed^[We'll discuss how RavenDB cluster work in the next chapter in detail.]  The two nodes
> will quickly discover the conflicting updates on both the other side and generate a conflict. But it isn't guaranteed that they will do that inside
> the lock / unlock period. 
> 
> Another issue is the subject of timing, if two clients have enough of a clock skew, a client might consider a lock to have expired even though it is
> valid. Proper distributed locking require a consensus protocol of some kind and aren't trivial to build or use. RavenDB _have_ a consensus protocol
> but pessimistic locking is usually a bad fit for OLTP environment, and we decided to not implement it.

Typical uses for pessmistic locks are to lock a document while a user is editing it. That might sound like a good idea, but experience has shown that 
in most cases, it lead to a lot of trouble. Consider for example version control systems. If you are reading this book, you have likely used a SCM of
some kind. If you haven't, please stop reading this book and pick up a book about source control of _some_ kind, that is far more important.

Early source control systems (SourceSafe as a good example) used locks as their concurrency model, and that led to a lot of problems. Joe taking a lock
on the file and then leaving for vacation is a typical problem that is brought up in such cases. The same happens whenever you have pessimistic locks.
Implementing pessimistic locks also require you to implement forced lock release, "who is locking this document" feature and a whole bunch of management
functions around it. It is typically easier to implement optimistic concurrent or merging, and it matches most users expectations a lot more.

#### Offline optimistic concurrency

We looked at online optimistic concurrency in Listing 4.8, when we load a document into the session, modify it, and then save. In that time frame, if 
there was a change, we'll get a concurrency exception. But most software doesn't work like that. In a web application, you aren't going to keep the 
document session open for as long as the user is on the site. Instead, you'll use a session per request model, most likely. And the user will first 
load a page with the document's content and modify it in another request. There isn't a shared session in sight, so how can we implement optimistic
concurrency.

All you need to do is to send the etag of the document to the user, and accept it back when the user want to save the document. Listing 4.10 shows an
example of using two separate session with concurrency handling between them.

```{caption="Concurrent modifications of a support call" .cs}
long etag;
Supportcall callOne;

using(var sessionOne = store.OpenSession())
using(var sessionTwo = store.OpenSession())
{
  callOne = sessionOne.Load<SupportCall>("SupportCalls/238-B");
  etag = sessionOne.Advanced.GetEtagFor(callOne);
  
  var callTwo = sessionTwo.Load<SupportCall>("SupportCalls/238-B");
  
  callTwo.Ended = DateTime.Today.AddDays(1);
  
  sessionTwo.SaveChanges();
}

using(var sessionThree = store.OpenSession())
{
  sessionThree.Advanced.UseOptimisticConcurrency = true;

  callOne.Ended = DateTime.Today;

  sessionThree.Store(callOne, etag, callOne.Id);

  sessionThree.SaveChanges(); // will raise ConcurrencyException
}
```

The code in Listing 4.10 first load the support call in `sessionOne`, then load it again in `sessionTwo`, modify the support call and save it to the server. 
Both sessions are then closed, and we open a _new_ session. We call `Store`, passing the entity instance, the etag that we got from the first session as 
well as the document id. 

This give the RavenDB Client API enough information so we can do an optimistic concurrency check from the time we loaded `callOne` in the first session. In
web scenario you'll typically send the etag alongside the actual data, and get it back from the client to do the check. You might also want to checkout the 
`Changes API`, which is covered a little later in this chapter, which might be of help to get early change notifications when you need to implement offline
optimistic concurrency.

### Patching documents


### Bulk insert


### Deferring commands

### Waiting for replication or indexing

## Reading documents

### Lazy requests

### Streaming data

## Cross cutting concerns on the client

### Conventions

### Listeners

metadata, auditing

## Versioning and revisions

### Changes API


## How RavenDB uses JSON

The RavenDB Server and the RavenDB C# Client API use a dedicated binary format to represent JSON in memory. The whole of [Chapter 27](#blittable)
is dedicted to this format, but it is worth understanding a bit about how RavenDB think about JSON even at this stage. Typically you'll work
with JSON documents in their stringified form, a set of UTF8 characters with the JSON format. That is human readable, cheap to parse and quite
easy to read and work with.

But JSON parsing requires you to work in a streaming manner, which means that to pull up just a few values from a big document, you still need to
parse the full document. As it turns out, once a document is inside RavenDB, there are a _lot_ of cases where we want to just get a few values 
from it. Indexing a few fields is very common, and parsing the JSON each and every time can be incredibly costly. Instead, RavenDB accept the JSON
string on write and turn it into an internal format, called Blittable^[I don't like the name, but we couldn't come up with anything better]. 

A blittable json document is a format that allows RavenDB random access to any piece of information in the document without having to parse the 
document with property traversal cost of (amortised) O(1). Over the wire, RavenDB is sending JSON strings, but internally, it is all blittable.
The C# client is also using blittable format internally, since that helps a _lot_ with memory consumption and control. You generally won't see
that in the public API, but certain very low level operations may expose you to it.

Blittable documents are immutable once created and _must_ be disposed after you are done with them. Since the document session will typically hold
such blittable objects, the session _must_ also be disposed to make sure that all the memory it is holding is released. An important consideration
for the overall performance of RavenDB is that blittable documents always reside in native memory. This is done because it allows RavenDB fine grained
control over where and how the memory is used, reused and its life cycle. 

On the client side, using the blittable format means that we have to deal with reduced memory consumption and reduced fragmentation, and it also reduce
the speed of caching significantly.

## Caching

### Aggresive caching

## Data Subscriptions

### Versioned Subscriptions

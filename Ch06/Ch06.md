
# Inside RavenDB Indexes

In this chapter, we are going to go over a lot of the theoretical details and reasoning behind how RavenDB indexes work. You'll not actually learn how to _use_ the indexes in this query, but you'll learn all about their details. You can feel free to skip this chapter for now, and go straight ahead to the next one to read the practical details on using indexes. But come back here and read this chapter at your leisure, it contains a lot of very important information about how RavenDB operates internally.

We have already done quite a bit with RavenDB, but we haven't talked about indexing at all and very little about querying. That doesn't mean that we didn't _use_ indexes, however. Let us consider the following query:
	
	var recentOrdersQuery =
		from order in session.Query<Order>()
		where order.Company == "companies/1"
		orderby order.OrderedAt descending
		select order;

	var recentOrders = recentOrdersQuery.Take(3).ToList();

How does a query like that work, on the server side? If you are used to relational databases, you might assume that the following pseudo code is run:

	var results = new List<Order>();
	foreach(var order in GetAllDocumentsFor("Orders")) {
		if(order.Company == "companies/1")
			results.Add(order);
	}
	results.Sort((x,y) => y.OrderedAt.CompareTo(x.OrderedAt));

This type of operation is called a table scan, and it is quite frequent in relational databases. This is also quite efficent, as long as the number of items you have in the database is very small. It tends to fail pretty horribly the moment your data size reach any significant size.
I've run into variants of this issues at customers over and over again, and when the time came to designing RavenDB, I decided that as part of the Safe By Default culture, we will simply not support this problem.

*RavenDB does no table scans!* In fact, there are no O(N) operations in general in RavenDB queries. Given the title of this chapter, I'm sure that you can guess how we handle queries. We use indexes to speed up queries. Using an index turn a query from an O(N) operation to an O(logN) operation. For those of you who don't care about abstract computer science stuff, the difference is between waiting 30 minutes for a result, or getting it right away.

> **We haven't created any indexes, but we can query!**
>
> Yes, that is confusing, isn't it? RavenDB doesn't allow queries without an index to answer the question. Yet at the same time, it does support queries without first defining an index. 
> 
> The answer is very simple, RavenDB is a pretty smart beast, whenever you make a query, the query optimizer get a chance to look at that, and it select the appropriate index to use. But what happens when we don't _have_ such an index? Well, you obviously want to query that information, otherwise you won't have send the database this query. What to do...
> 
> The query optimizer at this point can figure out what you need to be index, and it will _create this index for you_. The details of this process are explained later in the chapter, but the key part to understand is that RavenDB can automatically optimize itself to answer the kind of queries that you execute.
> This happens on the fly and without requiring any human involvement. The more you use RavenDB, the smart it become and the faster it is in responding to requests.

But we are jumping ahead of ourselves here, we'll discuss the ad how querying optimization RavenDB does in the [dynamic indexing](#dynamic-indexing) section. Before we get there, let us look at a few standard RavenDB indexes first.

## How indexing works in RavenDB?

An index is a way for the database to organize information about your data so it will able to retrieve said data efficiently. Let us look at an index definition in RavenDB. In this case, we want to index the `Name` property of a `Product`, so we can search for a product by name. Listing 6.1 shows a simple index that will allow us to answer such a query.

```{caption="{Index definition for searching products by name}" .cs}
from product in docs.Products
select new 
{ 
	product.Name 
}
```

This doesn't look very much like an index, does it? It looks a Linq query. In fact, if we were to excute this query we'll get the following results:

----							----						
Alice Mutton					Chocolade					
Aniseed Syrup					CÃ´te de Blaye				
Boston Crab Meat				Escargots de Bourgogne		
Camembert Pierrot				Filo Mix					
Carnarvon Tigers				Flotemysost					
Chai							Geitost						
Chang							Genen Shouyu				
Chartreuse verte				Gnocchi di nonna Alice		
Chef Anton's Cajun Seasoning	Gorgonzola Telino			
Chef Anton's Gumbo Mix			Grandma's Boysenberry Spread
----							----						
Table: First 20 product names, sorted.

So how can this be an index? The answer is that this isn't actually the index. The link expression above is actually the _index definition_, this determine _what_ will be indexed (as well as exactly how, but we'll touch on that later). How does that work?

Let us look at Listing 6.1, this is the external respresentation of the index, but internally, we add need to track where the details came from so the end result is:

	from product in docs.Products
	select new { product.Name, **product.__document_id** }

The output of the index definition is a list of objects with a `Name` and a `__document_id` property. But what can we do with this? 

> The following isn't actually how this work in RavenDB, we'll get to the full details of that in a bit. This is an attempt to explain how RavenDB works by simplyfing things as much as possible.

Now that we have the data to be indexed, we can actually put this in the index. From a logical perspective, this is what is going on:

	var index = new Dictionary<string, string>(); // name --> doc id
	foreach(var indexEntry in results)
		index[indexEntry.Name] = indexEntry.__document_id;

And queries now become a simple issue of reading through the index and then sending the results back:

	// query for Name = Chang

	var docId = index["Chang"]
	return LoadDocument(docId);

Again, this isn't actually how it works, but it is a simple way of thinking about this.	And right now I want you to understand the general concept, rather than the actual details.

> **The `__document_id` property**
>
> The __document_id` is a reserved property named in RavenDB, it maps to the document id of the document, regardless of the client side convention. 

So, we use a linq expression to select the fields to index from our documents. We also add the relevant document id to the output, and then we put all of those details in an index. When we query, we use the index to figure out what is the actual document id that match the query, and then we load the document (or documents) from storage by id, and send it to the client.

For the rest of this chapter (and in general), we'll use the following terminology:

* **Indexing function** - the linq expression (such as the one in Listing 6.1) used to project the fields to be indexed from the documents.
* **Index entry** - the output of the indexing function. A single document can output zero or more index entries.

## Incremental indexing

By now, you have almost all the pieces you need to understand how RavenDB indexing works. In Chapter 4, we discussed [etags](#etags). An etag is just an ever increasing number that changes whenever a document changes. Because a RavenDB database can contain a _lot_ of documents, it isn't practical to run the indexing function over the entire data set every time. Instead, we do incremental indexing, and we do that using the etag. Listing 6.2 shows a simplified version of how indexing works.

```{caption="{Highly simplified indexing process}" .cs}
while (databaseIsRunning) {
	var lastDocEtag = GetLatestEtagForAllDocuments();
	var lastIndexEtag = GetLastIndexedEtagFor("Products/ByName");

	if(lastDocEtag == lastIndexEtag) { 
		// index is up to date
		WaitForDocumentsToChange();
		continue;
	}
	
	var docsToIndex = LoadDocumentsAfter(lastIndexEtag);
	for(var indexEntry in indexingFunc(docsToIndex)) {
		StoreInIndex(indexEntry);
	}
	SetLastIndexEtag("Products/ByName", docsToIndex.Last().Etag);
}
```

I'll repeat again that Listing 6.2 shows the _conceptual_ model, the actual working of this is very different.

## Background indexing

In relational databases, indexes are computed as part of the same write transaction. That leads to an interesting tradeoff. If you don't have the right indexes, you are falling back to a table scan, and all the performance degredation that comes with that. So you want your indexes to cover all the columns you are querying. But the more indexes you have, the slower writes become.

It ends up being up to the DBA, who need to make a judgement call. And often the DBA need to make that judgement call without a lot of information. The decision need to be made upfront, before the DBA has any actual performance numbers. With RavenDB, we chose a different approach.

## Document Storage & Indexing Storage

## Indexing optimizations

### Prefetching

### Batch sizes

## Lucene 

## Dynamic indexing

## How RavenDB index documents?